// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

datasource db {
  provider  = "postgresql"
  url       = env("POSTGRES_PRISMA_URL") // uses connection pooling
  directUrl = env("POSTGRES_URL_NON_POOLING") // uses a direct connection
}

generator client {
  provider = "prisma-client-js"
}

enum Role {
  USER
  ADMIN
}

model User {
  id                  String               @id @default(cuid())
  name                String?
  // if you are using Github OAuth, you can get rid of the username attribute (that is for Twitter OAuth)
  username            String               @unique
  ghUsername          String?              @map("gh_username") // TODO @unique
  email               String?              @unique
  emailVerified       DateTime?            @map("email_verified")
  discordId           String?              @unique @map("discord_id")
  image               String?
  role                Role                 @default(USER)
  createdAt           DateTime             @default(now()) @map("created_at")
  updatedAt           DateTime             @updatedAt @map("updated_at")
  feedback            Json?                @db.JsonB // Store feedback data including submission status and content
  accounts            Account[]
  sessions            Session[]
  sites               Site[]
  deviceCodes         DeviceCode[]
  accessTokens        AccessToken[]
  githubInstallations GitHubInstallation[]
}

model Subscription {
  id                   String             @id @default(cuid())
  siteId               String             @unique @map("site_id")
  stripeCustomerId     String             @unique @map("stripe_customer_id")
  stripeSubscriptionId String             @unique @map("stripe_subscription_id")
  stripePriceId        String             @map("stripe_price_id") // to track which price/plan the subscription is for
  status               SubscriptionStatus
  interval             String // month, year
  currentPeriodStart   DateTime           @default(now()) @map("current_period_start")
  currentPeriodEnd     DateTime           @map("current_period_end")
  cancelAtPeriodEnd    Boolean            @default(false) @map("cancel_at_period_end")
  createdAt            DateTime           @default(now()) @map("created_at")
  updatedAt            DateTime           @updatedAt @map("updated_at")
  site                 Site               @relation(fields: [siteId], references: [id], onDelete: Cascade)

  @@index([siteId])
}

// NextAuth.js model - DO NOT modify this model's structure unless specified in NextAuth.js documentation
// See: https://next-auth.js.org/adapters/prisma
model Account {
  id                       String  @id @default(cuid())
  userId                   String
  type                     String
  provider                 String
  providerAccountId        String
  refresh_token            String?
  refresh_token_expires_in Int?
  access_token             String?
  expires_at               Int?
  token_type               String?
  scope                    String?
  id_token                 String?
  session_state            String?
  oauth_token_secret       String?
  oauth_token              String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
}

// NextAuth.js model - DO NOT modify this model's structure unless specified in NextAuth.js documentation
// See: https://next-auth.js.org/adapters/prisma
model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

// NextAuth.js model - DO NOT modify this model's structure unless specified in NextAuth.js documentation
// See: https://next-auth.js.org/adapters/prisma
model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model Site {
  id                      String        @id @default(cuid())
  // TODO(legacy-oauth): drop once all sites are migrated to GitHub App.
  // For GitHub App sites, repo name is derived via installationRepository relation.
  ghRepository            String?        @map("gh_repository")
  ghBranch                String?        @map("gh_branch")
  subdomain               String?       @unique
  customDomain            String?       @unique @map("custom_domain")
  rootDir                 String?       @map("root_dir")
  projectName             String        @map("project_name")
  createdAt               DateTime      @default(now()) @map("created_at")
  updatedAt               DateTime      @updatedAt @map("updated_at")
  user                    User          @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  userId                  String        @map("user_id")
  autoSync                Boolean       @default(false) @map("auto_sync")
  webhookId               String?       @unique @map("webhook_id")
  enableComments          Boolean       @default(false) @map("enable_comments")
  giscusRepoId            String?       @map("giscus_repo_id")
  giscusCategoryId        String?       @map("giscus_category_id")
  enableSearch            Boolean       @default(false) @map("enable_search")
  plan                    Plan          @default(FREE)
  subscription            Subscription?
  blobs                   Blob[]
  tree                    Json?         @db.JsonB // GitHub tree data
  privacyMode             PrivacyMode   @default(PUBLIC) @map("privacy_mode")
  accessPasswordHash      String?       @map("access_password_hash")
  accessPasswordUpdatedAt DateTime?     @map("access_password_updated_at")
  tokenVersion            Int           @default(0) @map("token_version")
  syntaxMode              SyntaxMode    @default(auto) @map("syntax_mode")

  // Anonymous/temporary site fields for claim flow
  isTemporary             Boolean       @default(false) @map("is_temporary")
  expiresAt               DateTime?     @map("expires_at")
  anonymousOwnerId        String?       @map("anonymous_owner_id")

  // Links to specific repo within the GitHub App installation
  installationRepositoryId String?                       @map("installation_repository_id")
  installationRepository   GitHubInstallationRepository? @relation(fields: [installationRepositoryId], references: [id])

  @@index([userId])
  @@index([installationRepositoryId])
  @@index([expiresAt])
  @@index([anonymousOwnerId])
}

model Blob {
  id         String   @id @default(cuid())
  site       Site     @relation(fields: [siteId], references: [id], onDelete: Cascade)
  siteId     String   @map("site_id")
  path       String // Original file path
  appPath    String?  @map("app_path") // URL slug
  permalink  String? // Obsidian permalink from frontmatter
  size       Int
  sha        String
  metadata   Json     @db.JsonB
  extension  String? // File extension
  width      Int? // Original image width in pixels
  height     Int? // Original image height in pixels
  syncStatus Status   @default(UPLOADING) @map("sync_status")
  syncError  String?  @map("sync_error")
  createdAt  DateTime @default(now()) @map("created_at")
  updatedAt  DateTime @updatedAt @map("updated_at")

  @@unique([siteId, path])
  @@index([siteId])
  @@index([siteId, permalink])
}

enum Status {
  UPLOADING  // Presigned URL generated, awaiting upload to R2
  PROCESSING // Upload complete, content being processed (md/mdx parsing)
  SUCCESS    // Fully complete and ready to serve
  ERROR      // Failed at some stage
}

enum Plan {
  FREE
  PREMIUM
}

enum SubscriptionStatus {
  active
  canceled
  past_due
  incomplete
  incomplete_expired
  trialing
  unpaid
  paused
}

enum PrivacyMode {
  PUBLIC
  PASSWORD // single shared password
  // MEMBERS    // (optional) require NextAuth session
}

enum SyntaxMode {
  md
  mdx
  auto
}

enum TokenType {
  CLI
  PAT
}

// OAuth Device Flow for CLI authentication
model DeviceCode {
  id         String   @id @default(cuid())
  deviceCode String   @unique @map("device_code")
  userCode   String   @unique @map("user_code")
  expiresAt  DateTime @map("expires_at")
  interval   Int      @default(5) // polling interval in seconds

  // After user authorizes
  userId       String?   @map("user_id")
  user         User?     @relation(fields: [userId], references: [id], onDelete: Cascade)
  authorized   Boolean   @default(false)
  authorizedAt DateTime? @map("authorized_at")

  createdAt DateTime @default(now()) @map("created_at")

  @@index([deviceCode])
  @@index([userCode])
  @@index([expiresAt])
}

// CLI and PAT authentication tokens
model AccessToken {
  id     String    @id @default(cuid())
  token  String    @unique // hashed token
  name   String? // optional user-provided name
  type   TokenType
  userId String    @map("user_id")
  user   User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  lastUsedAt DateTime? @map("last_used_at")
  expiresAt  DateTime? @map("expires_at") // optional expiration
  createdAt  DateTime  @default(now()) @map("created_at")

  @@index([userId])
  @@index([token])
}

// GitHub App installation tracking
// Many-to-many: Same installation can be linked to multiple users
model GitHubInstallation {
  id             String    @id @default(cuid())
  installationId BigInt    @map("installation_id") // GitHub's installation ID
  accountType    String    @map("account_type") // 'User' | 'Organization'
  accountLogin   String    @map("account_login") // username or org name
  accountId      BigInt    @map("account_id") // GitHub account ID
  userId         String    @map("user_id")
  user           User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  suspendedAt    DateTime? @map("suspended_at")
  suspendedBy    String?   @map("suspended_by")
  createdAt      DateTime  @default(now()) @map("created_at")
  updatedAt      DateTime  @updatedAt @map("updated_at")

  repositories GitHubInstallationRepository[]

  @@unique([installationId, userId]) // Composite unique: each user can link once
  @@index([userId])
  @@index([installationId])
  @@index([accountId]) // For finding installations by GitHub account
}

// Repositories accessible through a GitHub App installation
model GitHubInstallationRepository {
  id                 String             @id @default(cuid())
  installationId     String             @map("installation_id")
  installation       GitHubInstallation @relation(fields: [installationId], references: [id], onDelete: Cascade)
  repositoryId       BigInt             @map("repository_id") // GitHub repo ID
  repositoryName     String             @map("repository_name")
  repositoryFullName String             @map("repository_full_name") // 'owner/repo'
  isPrivate          Boolean            @default(false) @map("is_private")
  createdAt          DateTime           @default(now()) @map("created_at")
  sites              Site[]

  @@unique([installationId, repositoryId])
  @@index([installationId])
  @@index([repositoryFullName])
  @@index([repositoryId])
}
