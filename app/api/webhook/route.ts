import { NextRequest } from "next/server";
import prisma from "@/server/db";
import { env } from "@/env.mjs";
import { inngest } from "@/inngest/client";
import axios from "axios";

// TODO https://www.inngest.com/docs/platform/webhooks
export async function POST(req: NextRequest) {
  const event = req.headers.get("x-github-event");

  if (event === "ping") {
    return new Response("Event processed", { status: 200 });
  }

  const secret = env.GH_WEBHOOK_SECRET;
  const signature = req.headers.get("x-hub-signature")!;
  const payload = await req.json();

  if (!verifySignature(secret, signature, payload)) {
    return new Response("Invalid signature", { status: 401 });
  }

  const webhookId = req.headers.get("x-github-hook-id");
  const siteId = req.nextUrl.searchParams.get("siteid");

  let site;
  if (siteId) {
    site = await prisma.site.findUnique({
      where: {
        id: siteId,
      },
      include: {
        user: true,
      },
    });
  }

  // DON'T REMOVE
  // this is for backwards compatibility for sites that had webhooks created without the siteid query param
  if (!site && webhookId) {
    site = await prisma.site.findUnique({
      where: {
        webhookId,
      },
      include: {
        user: true,
      },
    });
  }

  if (!site) {
    return new Response("Site not found", { status: 404 });
  }

  if (env.NEXT_PUBLIC_VERCEL_ENV === "production") {
    try {
      const payload = {
        // client_it should in theory be the client_id auto generated by GTM and stored in a cookie, but we can't easily get it here
        // however, since we're also using the userId in params, it will still be associated with any other events
        // from that signed in user, doesn't matter if it's the same client_id or not
        // could probably be even a random string
        client_id: site.userId,
        events: [
          {
            name: "auto_sync",
            params: {
              user_id: site.userId,
              site_id: site.id,
            },
          },
        ],
      };
      await axios.post(
        `https://www.google-analytics.com/mp/collect?measurement_id=${env.GA_MEASUREMENT_ID}&api_secret=${env.GA_SECRET}`,
        payload,
      );
    } catch (error) {
      console.error("Error sending GTM event", error);
    }
  }

  if (payload.ref !== `refs/heads/${site.ghBranch}` || event !== "push") {
    return new Response("Incorrect branch", { status: 404 });
  }

  const account = await prisma.account.findFirst({
    where: {
      userId: site.userId!,
    },
  });

  await inngest.send({
    name: "site/sync",
    data: {
      siteId: site.id,
      ghRepository: site.ghRepository,
      ghBranch: site.ghBranch,
      rootDir: site.rootDir,
      accessToken: account!.access_token!,
    },
  });

  return new Response("Event processed", { status: 200 });
}

const encoder = new TextEncoder();

// Verify the GitHub webhook secret
async function verifySignature(
  secret: string,
  header: string,
  payload: string,
) {
  const parts = header.split("=");
  const sigHex = parts[1]!;

  const algorithm = { name: "HMAC", hash: { name: "SHA-256" } };

  const keyBytes = encoder.encode(secret);
  const extractable = false;
  const key = await crypto.subtle.importKey(
    "raw",
    keyBytes,
    algorithm,
    extractable,
    ["sign", "verify"],
  );

  const sigBytes = hexToBytes(sigHex);
  const dataBytes = encoder.encode(payload);
  const equal = await crypto.subtle.verify(
    algorithm.name,
    key,
    sigBytes,
    dataBytes,
  );

  return equal;
}

function hexToBytes(hex: string) {
  const len = hex.length / 2;
  const bytes = new Uint8Array(len);

  let index = 0;
  for (let i = 0; i < hex.length; i += 2) {
    const c = hex.slice(i, i + 2);
    const b = parseInt(c, 16);
    bytes[index] = b;
    index += 1;
  }

  return bytes;
}
